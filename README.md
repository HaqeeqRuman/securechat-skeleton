SecureChat – Assignment #2
CS-3002 Information Security – Fall 2025

SecureChat is a console-based secure messaging system built without TLS, implementing Confidentiality, Integrity, Authenticity, and Non-Repudiation (CIANR) using application-layer cryptography.

All crypto operations are performed manually using AES, RSA, Diffie–Hellman, SHA-256, and X.509 certificates signed by a custom Root CA.

This README explains the environment setup, protocol workflow, cryptographic design, usage instructions, and the results of all required security tests.

1. Features

SecureChat implements:

PKI and Certificates
Client and server exchange X.509 certificates and verify them using the local Root CA.

Two Diffie–Hellman Exchanges
DH #1 produces K_auth for encrypted login.
DH #2 produces K_chat for encrypted chat messages.

AES Encryption (ECB + PKCS#7)
Used for confidentiality of credentials and messages.

RSA Signatures (SHA-256)
Every chat message is digitally signed for integrity and authentication.

Replay Protection
Each endpoint enforces strictly increasing sequence numbers.

Append-Only Transcript with TranscriptHash
All messages logged for auditing and non-repudiation.

Signed SessionReceipt
Verifiable proof of session integrity.

2. Project Structure
securechat-skeleton/
├─ app/
│  ├─ client.py
│  ├─ server.py
│  ├─ crypto/
│  │  ├─ aes.py
│  │  ├─ dh.py
│  │  ├─ pki.py
│  │  └─ sign.py
│  ├─ common/
│  │  ├─ protocol.py
│  │  └─ utils.py
│  └─ storage/
│     ├─ db.py
│     └─ transcript.py
├─ scripts/
│  ├─ gen_ca.py
│  └─ gen_cert.py
├─ transcripts/
├─ certs/
├─ tests/manual/
├─ requirements.txt
└─ README.md

3. Setup Instructions
Create environment
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
cp .env.example .env

MySQL setup (Docker recommended)
docker run -d --name securechat-db \
    -e MYSQL_ROOT_PASSWORD=rootpass \
    -e MYSQL_DATABASE=securechat \
    -e MYSQL_USER=scuser \
    -e MYSQL_PASSWORD=scpass \
    -p 3306:3306 mysql:8


Create database tables:

python -m app.storage.db --init

Generate certificates
python scripts/gen_ca.py --name "FAST-NU Root CA"
python scripts/gen_cert.py --cn server.local --out certs/server
python scripts/gen_cert.py --cn client.local --out certs/client

4. How the System Works (Full Workflow)

This section explains the cryptographic logic implemented in the assignment.

4.1 PKI Hello

Client sends its certificate + nonce.
Server responds with its certificate + nonce.

Client verifies:

• CA signature
• Certificate validity dates
• Common Name matches server.local

Server does the same for the client.

4.2 Diffie–Hellman Exchange #1

Generates a shared AES key called K_auth.

Used only for encrypted login or registration.

Process:

• A1 = g^a mod p
• B1 = g^b mod p
• shared_secret = B1^a mod p
• K_auth = SHA256(shared_secret)[0:16]

4.3 Encrypted Login / Register

Credentials are encrypted with AES-128-ECB using K_auth.

Server decrypts, verifies user in MySQL, and authenticates.

4.4 Diffie–Hellman Exchange #2

Produces K_chat used for all encrypted chat messages.

4.5 Secure Chat Messages

Each chat message contains:

• seqno
• timestamp
• ciphertext (AES-ECB)
• RSA signature over:
"{seq}|{timestamp}|{ct}"

Receiver verifies:

• Sequence strictly increasing
• RSA signature valid
• AES decrypts successfully

If signature fails → SIG_FAIL
If replayed seqno → REPLAY

4.6 Append-Only Transcript

Every event is written to:

transcripts/session-XXXXXXXX-client.log
transcripts/session-XXXXXXXX-server.log


Each transcript ends with a SHA-256 hash of all prior lines.

4.7 SessionReceipt for Non-Repudiation

At the end of the session:

• Compute transcript_hash
• Sign it using RSA private key
• Send SessionReceipt message

Anyone offline can verify:

• Transcript integrity
• Signature authenticity
• Sequence coverage (first_seq to last_seq)

5. Running the System

Start server:

python -m app.server


Start client:

python -m app.client


Client prompts:

Auth mode [register/login]:
Email:
Password:


Then chat begins:

client> hello
[SERVER #1] hi


Exit with:

client> exit

6. Test Results (Required by Assignment)

Below are the exact behaviors generated by the implementation.

6.1 Wireshark Evidence

All chat contents appear only as encrypted AES ciphertext.
No plaintext credentials or messages appear in packet capture.

6.2 Invalid / Self-Signed Certificate Test

If the server presents a wrong certificate:

[BAD_CERT] Server certificate invalid


Connection terminates immediately.

6.3 Tamper Test – Signature Failure

Manually flipping one bit in ciphertext or signature:

[SIG_FAIL] Dropping message


Message is discarded without decryption.

Integrity and authenticity verified correctly.

6.4 Replay Test – Duplicate Sequence Number

If an old message is re-sent:

[REPLAY] seq=2 (last 2)


Replay successfully detected and rejected.

6.5 Non-Repudiation Test

Run:

python verify_nonrepudiation.py


Expected output:

[MSG] seq=1 from=client sig_ok=True
[MSG] seq=1 from=server sig_ok=True
[MSG] seq=2 from=client sig_ok=True
...

[HASH] Recomposed TranscriptHash = <value>

[CHECK] Receipt signature valid: True
[CHECK] TranscriptHash match: True


If you modify even a single character in the transcript:

TranscriptHash mismatch


Non-repudiation verified.

7. Known Correct Behavior

• Valid messages decrypt and verify normally
• Tampered messages fail signature check
• Replay attempts rejected by seqno
• Invalid certificates rejected
• Transcript hash consistent across client and server
• SessionReceipt signature passes offline verification

8. Conclusion

This project demonstrates a complete secure communications protocol built entirely at the application level. The SecureChat system successfully integrates PKI, DH, AES, RSA, replay protection, transcript auditing, and non-repudiation.
